<h1>Overview</h1>

<p>Axoloti consists of both hardware and software which work together to provide a virtual modular environment.
With the Axoloti software we can create 'patches' which are uploaded to the Axoloti hardware and then run on the hardware.</p>

<p>When we upload these patches to the Axoloti board, we are actually uploading native code for the hardware and not interpreting these patches on the board. 
This means it runs very efficiently, close to the efficiency you would get if you wrote the code specifically for the hardware!</p>

<p>Although this particular document concentrates on the Axoloti software, once the 'patch' is uploaded to the board, the Axoloti board can run completely independently, no computer or other controller is required.</p>

<p>You can find more information about the hardware in another post in this "User Guide" </p>

<p>More topics from the user guide can be found in the <a href="http://community.axoloti.com/c/user-guide">Axoloti User Guide Forum</a></p>

<h1>Learning Axoloti</h1>

<p>Axoloti is fairly simple to use, especially if you are used to graphical patching languages.
This topic covers the basic of how to use the computer side of axoloti 'the GUI', and an introduction into some of the aspects you will encounter.</p>

<p>After reading this, we would recommend you open each of the tutorial patches ( File -> Library-> Factory -> Tutorials)  to get an understanding of how to patch your own objects. From there, you can start looking at the factory demo which are more complex. 
This should give you a basic understanding of how to get started creating your own patches, from there you can look at community patches, and of course ask questions here on the forum.</p>

<p>Many users like to have a more 'tutorial book' approach, and we are lucky that such a book has been independently produced by a community member @janvantomme , which many users have commented is a great place to start - you can read more about this book, and feed back from users here <a href="http://community.axoloti.com/t/getting-started-with-axoloti-the-book">Getting started with Axoloti book</a> . </p>

<h1>Axoloti GUI</h1>

<p>The main focus of the Axoloti GUI is to allow the user to connect to the Axoloti hardware, build patches and upload these patches to the hardware.
To do this there are two main windows, the console window and the patch window. 
There is always one console window, but you can have many patch windows open.</p>

<h1>Console Window</h1>

<p>The console window shows information about the axoloti board that is connected, and various log messages.
Assuming your axoloti board is connected, the first thing you will want to do is to ensure it is connected.
(after the first time, it will automatically connect when you start Axoloti)</p>

<p>First, use the 'Board Menu' and select 'Select Device', and you will see one (or more) Axoloti boards that are available for connection (if not, check your USB cables). Select the device, and press ok.
Now you can use the 'connect' button on the Console window, it will print 'connected' in the log, as well as the current firmware version.
This console window also shows the current firmware revision on the board, this is covered in the "Firmware vs Patch" post in the user guide.</p>

<p>Note: see how connected was in RED, this shows an important log message, often errors that need the users attention.</p>

<p>We will be looking at the console window more, when we discuss transferring patches to the Axoloti board.</p>

<h1>Patch Window</h1>

<p>This is where the fun starts, as this is where we create our synths, sequencers, or what ever else is in our imagination.
Lets start by looking at a patch to see what we can do....</p>

<p>Use the File menu, and you can see there are options to create a new patch, open patch... and also a Library menu, which contains tutorials and demos.
So lets start with a demo. </p>

<h2>Loading a demo</h2>

<p>in the console window's File menu, use:
File -> Library -> demos -> youtube ->tybett</p>

<p>This will open a patch with with the Tybett demo that has been shown on YouTube.
It might look complicated, but you will soon get accustomed to what is going on, and we are only here to see a few important things.</p>

<p>With this patch window we can see lots of objects all connected by wires, more on this later.
the most important thing about the patch window though is there are two modes.</p>

<p>Edit Mode - (light background) , allows you to edit the patch.
Live mode - (dark background) the patch is running on the Axoloti board, and you can control the parameters.</p>

<p>When you open a patch, you always start in Edit mode.</p>

<h1>Live Mode</h1>

<p>Lets start with some sound!  (assuming you have the output jack connected to your speakers/mixer)</p>

<p><strong>Important Note</strong> When you use a patch that you have not used before, or you have only just created <strong>always</strong> start with the gain on your headphones/mixer/speakers LOW and turn it up gradually. Different patches can have different volume levels and you don't want to damage your speakers/hearing!</p>

<p>ok, so to send this patch to the Axoloti board  - you can press the Live checkbox.
as this is a patch using a sequencer, you will instantly hear sound.</p>

<p>Importantly you will see the background has changed colour to dark grey, this clearly indicates the patch is Live, and running on the Axoloti board.</p>

<p>In Live mode, you can change the parameters that are on the screen.
have a go, in the top right, you will see a box labelled LFO/Square, this object is controlling the tempo of this patch, you can use the mouse to control the dial in the box,  by clicking on the dial with the mouse, and then moving up or down.  (This can also be controlled via MIDI, but more on that later!)</p>

<p>Also in Live mode you can use the preset recalls buttons at the top to change between different sets of saved presets, which are different groups of parameters values. (more later!)</p>

<p>Note: when in  LIVE mode, you cannot edit the patch in any way (including moving objects). (
as it is already loaded and running on the axoloti board) , to edit it you must leave LIVE mode. <br>
Also can only have one patch running on a particular board at a time.</p>

<p>Engaging live mode generates compatible code from the patch, compiles the code, uploads the binary and starts the binary on the board. In live mode, only parameters can be changed. Connections, execution order, location, attributes,... are all frozen. 
Currently midi mapping, and modulation can be adjusted in live mode, but those changes are only in effect until after engaging live mode again.</p>

<p>Leaving Live mode, easy... just click the Live checkbox again 
(you will see you can also press CTRL/CMD +E as a shortcut for entering/leaving Live mode)</p>

<h1>Edit Mode</h1>

<p>Ok before we start editing lets get a little familiar with what a patch is...</p>

<p>The boxes are referred to as 'objects', and are like modules in a modular synth.
objects contain inlets to connect to, and outlets to connect to other objects by using  virtual wires or connections.</p>

<h2>Objects</h2>

<p>Each objects has:</p>

<ul>
<li>titlebar, containing the kind of object</li>
<li>instance name, the name you give it (a default is generated) Note: duplicate names in a patch are illegal.</li>
<li>inlets: colored circles on the left side</li>
<li>outlets colored squares on the right side</li>
<li>attributes values that can only be set before running the patch.</li>
<li>parameters values that can be set before loading the patch and also be modified during a "live" session. </li>
</ul>

<p>and some objects (called displays) also display various visualisations of live data from the patch.</p>

<p>Operations on objects:  (not in Live Mode):</p>

<ul>
<li>Objects can be moved by dragging the titlebar.</li>
<li>Objects can be selected by clicking the titlebar, or dragging a rectange around a group.</li>
<li>Selected objects can be deleted by pressing delete or backspace.</li>
<li>Objects can be replaced with a different type by double-clicking on the title (or selecting replace in the context menu). Connections and parameters will be preserved. Attributes are not preserved (yet), this is especially useful when you wish to change inlet/outlet types (e.g. control rate to audio rate)</li>
<li>Instance name can be changed (a double click on the instancename brings up the instance name editor)</li>
<li>Attributes can be changed</li>
<li>Parameters can be changed by:
<ul>
<li>mouse for units, + shift for sub-units, +shift+ctrl for fine units (e.g 0.5,0.05,0.01)</li>
<li>arrow-up/down. shift-arrow-up/down</li>
<li>page-up/down</li>
<li>home, end</li>
<li>typing the number followed by enter</li>
</ul></li>
</ul>

<p><strong>Parameters,  Attributes and Displays</strong>
An object can have 3 types of user interface elments
Parameters - which can be changed at run time.  i.e. when Live  (and can also be modulated or controlled via midi CC)
Attributes - can only be configured whilst editing the patch.
Displays - show data coming from the axoloti board e.g. an oscilloscope (scope)</p>

<p>Attributes are used where there would be too great an overhead to change them at run-time, which could potentially disrupt the audio e.g. increasing a delay line's size at run time could cause audio glitches.
(the most common cases are for configuring buffer sizes/delay lines or configuring which tables/delays things are read from ... often they are text fields or drop down boxes - If you cant change it at run-time, its an attribute :) )</p>

<p>Some parameters have real-world units, displayed left of the dial. For some, multiple conversions are meaningful. Clicking on the real-world unit to alternate between different units. Eg. frequency in Hertz or period time in milliseconds.
Parameter can be mapped to MIDI Continuous Controllers, by right clicking on the parameter to assign a MIDI controller. Mapped parameters have a "C" mark right of the dial.
Parameters can be modulated by other objects, right click on the parameter and select modulate, Modulated parameters have a "M" marked to right of the dial</p>

<h1>Connections</h1>

<h2>Connecting wires</h2>

<p>Just drag an inlet to outlet (or vice versa)
An outlet can connect to many inlets BUT an inlet can only be connected to one outlet.
If you wish to connect 2 outlets to an inlet you will need to mix/sum them.</p>

<h2>Disconnect a wire</h2>

<ul>
<li>select it and press delete </li>
<li>right click on a inlet/outlet and select disconnect</li>
<li>drag the connected inlet/outlet into space</li>
</ul>

<h2>Changing inlet source</h2>

<p>if you want to change the outlet an inlet is connected to, simply drag the new outlet to the inlet, and the connection will be replaced</p>

<h2>Connection network</h2>

<p>a connection network is all of the wires that are connected to a particular outlet.
you can delete them all at once with delete network</p>

<h2>Connection (and Inlet/Outlet types)</h2>

<p>Different data types are marked by different colors on the outlets, inlets and wires.</p>

<ul>
<li>Red connections are s-rate ( audio/sample rate - 48000 Hz). The normal range is -64 to 64 units.</li>
<li>Blue connection points are k-rate (control-rate, 3000 Hz) fractional numbers. The normal range is -64 to 64 units, like control voltages on a modular synthesizer.</li>
<li>Yellow connections are for k-rate booleans, like gate signals one a  modular synthesizer.</li>
<li>Green connections are for k-rate integers (whole numbers). The range is a signed 32bit , e.g. -2147483648 to 2147483647. </li>
<li>Pink connections are for strings. Mostly useful for dynamic filenames.</li>
</ul>

<h2>Connections between different types</h2>

<ul>
<li>A red output (audio) can be connected to a blue input (float), this will sample the audio, 1 in 16 audio samples.</li>
<li>A yellow output (boolean) can be connected to a blue input (float), this yields +64 units for true, 0 for false.</li>
<li>A yellow output (boolean) can be connected to a green input (float), this yields 1 for true, 0 for false.</li>
<li>A green output (integer) can be connected to a blue input(float).</li>
<li>A green output (integer) can be connected to a yellow input (boolean), evaluates to true when the value is positive, or to false when zero or negative.</li>
<li>A blue output (float) can be connected to a green input (integer) the value is rounded down.</li>
<li>A blue output (float) can be connected to a yellow input (boolean), evaluates to true when the value is positive, or to false when zero or negative.</li>
<li>A pink output must always be connected to a pink input. (strings)</li>
</ul>

<h1>Execution order</h1>

<p>Every object in the patch is executed once in the signal processing loop, at 3000Hz. 
These are processed in strict order, left to right, top to bottom.
(Feedback is allowed, and will be processed in the next processing loop)</p>

<h1>Documenting patches</h1>

<p>Use comment objects and the patch notes (accessible from the menu) so you don't forget how your patch works, also changing the instance name (menu rename) helps when you have many objects of the same type</p>

<h1>Saving a patch</h1>

<p>Once you have created a patch, you can then save it using the File menu, and choose Save or Save As. </p>

<h2>Presets</h2>

<p>A preset is a set of selected parameters and their new value. To include a parameter to a preset, select the preset index to edit in the toolbar. Then right-click on a parameter and select "include in current preset" in the popup-menu. The parameter will turn yellow. A yellow parameter is not updated live, but indicates that you are adjusting its value in the preset. Changes to presets are only updated after dis- and re-engaging the live checkbox! Presets in a sub-patch can be applied only with the "preset" object. A preset in a "normal" sub-patch only affects the sub-patch. A preset in a polyphonic sub-patch only affects one voice.</p>

<h1>Sub patching</h1>

<p>Sub patches are an important building block in Axoloti.</p>

<p>There are lots of uses for sub patches but the main reasons are:</p>

<ul>
<li>creating 'utility' patches that you want to use in many patches</li>
<li>to simplify a very complex patch</li>
<li>for polyphonic voices </li>
</ul>

<p>Terminology, sometimes sub patches will be referred to as 'child patches' and the main patch is called the parent patch.</p>

<p>Sub patches can be create in two different ways, either embedded into the patch (i.e. saved in the AXP) or as a separate file (AXS) . Functionally they operate the same, the difference is embedded patch does not need to be saved separately, but cannot then be re-used on other patches. 
Most often embedded patches are used, especially during 'development' of a patch, and the subpatch files (AXS) are create if you wish to use the same functionality in other patches.
(note: you can copy and paste embedded patches, like other objects , but of course this means any change you want to make has to be made to individual copies)</p>

<h2>Embedded sub patches</h2>

<p>To create an embedded sub-patch </p>

<ul>
<li>create a new object of type 'patch/patcher'</li>
<li>click the edit object, this will open a new patch window for you to add contents</li>
<li>you can add inlet/outlet objects to communicate with main patch</li>
<li>you can edit the patch settings, e.g. to create multiple voices</li>
<li>you can add parameters to parent</li>
<li>once you have finished editing, close the window <strong>AND click update</strong> on the patch/patcher</li>
</ul>

<p>tip: remember you can rename the patch/patcher object to a more meaningful name.</p>

<p>using embedded patchers makes creating voices trivial, and keeps all of the patch in one file, which means its easy to share. you can even cut and paste embedded patchers to other patches to re-use them.</p>

<p>unless you have a particular reason to use sub-patch files, e.g. sharing in a library, you should use embedded patches.</p>

<h2>Sub patch files (AXS)</h2>

<p>Sub patches are just like main patches, but are saved with as 'Axoloti Subpatch' with an extension of AXS, the difference is they are never used on their own... they are always added to a main patch. 
(we will also see later that sub-patches can often look like normal axoloti objects)</p>

<p>a few important notes:</p>

<ul>
<li>to use a subpatch it must be saved (to disk) before you can included it in a main patch.</li>
<li>to edit a sub-patch used in a main patch, always use select in the main patch, and from the context menu select 'edit object defintition'</li>
</ul>

<p>to create a sub-patch:</p>

<ul>
<li>Create a new patch, (this will be the sub patch)</li>
<li>include inlet, and outlet objects allow data/audio to be passed to the main patch</li>
<li>Save this patch (as an Axoloti Subpatch,  into the directory you are going to save the main patch) </li>
<li>Create a new patch (this will be the parent)</li>
<li>Save this patch (as an Axoloti Patch, into the same directory as the sub patch above)</li>
<li>Bring up the object search window ( space/N)</li>
<li>Enter the patch filename in the object selector (without .axs extension), prefixed by "./"</li>
</ul>

<p>If you want to modify the sub patch:</p>

<ul>
<li>In the main patch, select the sub patch object</li>
<li>select "edit object definition" in the object popup menu</li>
<li>the sub patch window opens</li>
<li>make the changes</li>
<li>save the sub-patch.</li>
</ul>

<p>Note: If the main patch is LIVE, changes to a sub-patch will not be propagated until the main patch is sent again to the board (e.g. take it offline, then select live again)</p>

<p>Parameters can be propagated to the main patch by right-click on the parameter and select "show on parent". "Show on parent" parameters are drawn in blue.</p>

<p>Sub-patch files (AXS) are useful were you wish to create a generic object that you can use in many different patches, with the advantage that if you update the AXS all patches using it will use the new implementation.
(this 'advantage' can be considered a disadvantage if you want consistency in old patches... in which case you may prefer embedded patches or will need to version the AXS) </p>

<h1>Polyphonic Sub patching</h1>

<p>An important use of Sub patches is to create polyphonic voices.
If you place an oscillator in a patch, then you have one oscillator (with one pitch), what we need for polyphony is to have many copies of that oscillator, one for each voice.
The way we achieve this is to create a sub patch, the sub patch is then used for each voice.
When we add the sub-patch to the main patch we can say how many voices are created.
Now when midi notes are played Axoloti will automatically allocate notes played simultaneously to different voices. </p>

<p>Note: you can change some properties of how voices are allocated in the patch settings of the sub-patch, see "more on sub patching for details"</p>

<p>For sound design purposes, you can also obtain the index of the voice with the "voiceindex" object... useful to make voices have some variation.</p>

<h1>Patch Settings</h1>

<p>With every patch you can store notes (View->notes) and also change the patches settings.
Patch settiings include:</p>

<ul>
<li>Author, who wrote the patch</li>
<li>Licence, the license for using/sharing the patch</li>
<li>Midi Channel, if you are using midi objects what channel they receive data on  (affected by patch mode)</li>
<li>Number of presets - how many presets can be store on the patch</li>
<li>Entries per presets - the number of parameters that can be store on the preset</li>
<li>Number of modulation source - number of modulation source on the patch (patch/modsource*)</li>
<li>Number of modulation targets - number of targets for sources</li>
<li>Sub patch mode, how voices are handled, see 'more on sub patches'</li>
<li>Has midi channel attribute - the midi channel is exposed on the parent patch, when used as a subpatch</li>
<li>saturate audio - is the the audio output from this patch saturated</li>
</ul>

<h1>Zombies</h1>

<p>If a patch is loaded and an object cannot be found, a zombie will be created (its bright red!) , your patch will not work, so you need to replace it... simply double click, or use replace object. if you replace with something with compatible inlet/outlets it will remain connected!
(most likely to happen if you create your own subpatches and move them)</p>

<h1>File types</h1>

<p>Axoloti has 4 file types:
AXO  - objects with functionality, found in search window 
AXP  - patch, which contains objects and can be compiled and sent to Axoloti board
AXS  - subpatch, a patch used by a main patch (see below)
AXH - help patch, shows how to use an object.
all except AXO, can be created by saving the patch with Save As...</p>

<h1>Object and Sub-patch libraries</h1>

<p>By default axoloti will look in the objects sub-directory for objects files and sub-patches.
(if you start with ./ (as suggested in sub-patch section) this will also look in the same directory as the patch)</p>

<p>If you develop your own sub-patches that you wish to see as objects, or your own custom objects (axo) or third party objects, then this is possible, simply add them into a Library. 
if you want them privately then you can add then to the 'home' library,  or you can share them with the community by placing in the community library.</p>

<p>objects all have a unique id, that is allocated by the object editor.
however, currently (subject to change!) subpatches are uniquely identified by their name.
e.g midi/in/keyb
so what happens if you have multiple sub-patches with the same name?
axoloti will search using the following rules</p>

<ul>
<li>if it full path is given it will use this</li>
<li>if a relative path is given , it will use this relative to the location the patch is saved (so you need to save your parent patch first) </li>
<li>the order of libraries, listed in the preferences dialog</li>
</ul>

<p>Our recommendation is to use embedded patches and embedded objects as much as possible, or to place sub-patches/objects in library.</p>

<h1>Custom objects</h1>

<p>Creating custom objects is beyond the scope of this user guide.
however, a few notes are useful...
a) axoloti features an object editor which can be used to create your own objects
b) you can either embed custom objects or save objects in the a share library (as an axo file) 
generally custom objects are useful where a graphical UI becomes cumbersome, i.e. its simpler to right an algorithm in lines of code, or where some structure are not available in patch e.g. looping.</p>

<p>will custom objects be more efficient? this depends, only if you can express your 'intent' in a simpler/more concise efficeint way. custom objects  are <strong>not</strong> par se quicker (as both custom objects and patching both generate C code, which is subject to the optimiser). a badly written custom object is likely to perform worst/have more unwanted side effects than a patch!</p>

<p>if you want to create custom objects , axoloti provides all the tools 'out of the box', 
but you will need a few additional skills, depending on what you want to achieve.
- some programming experience
- some C coding experience (not too much , just the basics)*
- some DSP knowledge if you want to do audio
- some understanding of axoloti (id recommend deep patching experience , before object coding!)</p>

<p>*personally, Id recommend you do some C programming on the desktop first, as you lack things like debuggers in axoloti, and even getting trace output is more cumbersome.</p>
