#include "codec_WM8731.h"
#include "ch.h"
#include "hal.h"

#include "codec.h"
#include "stm32f4xx.h"
#include "axoloti_board.h"

#define CODEC_WM8731_I2S_ENABLE rccEnableSPI2(FALSE)
#define CODEC_WM8731_I2S_DISABLE rccDisableSPI2(FALSE)
#define CODEC_WM8731_I2S SPI2
#define CODEC_WM8731_I2Sext I2S2ext

#define STM_IS_I2S_MASTER true

#if (BOARD_STM32F4DISCOVERY)
#error "STM32F4DISCOVERY has a different codec, please update the makefile..."
#endif

extern void computebufI(int32_t *inp, int32_t *outp);

const stm32_dma_stream_t* i2sdma_WM8731;
const stm32_dma_stream_t* i2sdma_WM8731rx;

int codec_interrupt_timestamp;

#define I2S2_TX_DMA_CHANNEL \
STM32_DMA_GETCHANNEL(STM32_SPI_SPI2_TX_DMA_STREAM /* STM32_DMA_STREAM_ID(1, 4) */, \
STM32_SPI2_TX_DMA_CHN /* 0000 */)

#define I2S2ext_RX_DMA_CHANNEL \
STM32_DMA_GETCHANNEL(STM32_DMA_STREAM_ID(1, 3), \
3)

// static const SPIConfig spi1c_cfg = {NULL, /* HW dependent part.*/GPIOE, 8,
                                    // SPI_CR1_BR_0 | SPI_CR1_BR_1 | SPI_CR1_BR_2
                                        // | SPI_CR1_CPOL | SPI_CR1_CPHA};

void codec_WM8731_hw_reset(void) {
  WM8731_writeRegister(WM8731_REG_RESET, 0);
}

/* I2C interface #2 */
/* SDA : PB11
 * SCL : PB10
 */
static const I2CConfig i2cfg2 = {OPMODE_I2C, 400000, FAST_DUTY_CYCLE_2, };

static uint8_t i2crxbuf[8];
static uint8_t i2ctxbuf[8];
static systime_t tmo;

#define WM8731_I2C_ADDR 0x1A // address when CSB pin to ground
//#define WM8731_I2C_ADDR 0x1B

void CheckI2CErrors(void) {
  volatile i2cflags_t errors;
  errors = i2cGetErrors(&I2CD2);
  (void)errors;
}

void WM8731_I2CStart(void) {
  palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
  palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
  chMtxLock(&Mutex_DMAStream_1_7);
  i2cStart(&I2CD2, &i2cfg2);
}

void WM8731_I2CStop(void) {
  i2cStop(&I2CD2);
  chMtxUnlock();
}

uint8_t WM8731_writeRegister(uint16_t registerAddr, uint16_t data) {
  msg_t status;

  i2ctxbuf[0] = (registerAddr << 1) | ((data >> 8) & 1);
  i2ctxbuf[1] = data & 0xFF;

  WM8731_I2CStart();
  i2cAcquireBus(&I2CD2);

  status = i2cMasterTransmitTimeout(&I2CD2, WM8731_I2C_ADDR, i2ctxbuf, 2, i2crxbuf, 0, tmo);

  // if (status != RDY_OK) {
  //   CheckI2CErrors();
  //   status = i2cMasterTransmitTimeout(&I2CD2, WM8731_I2C_ADDR, i2ctxbuf, 2, i2crxbuf, 0, tmo);
  //   chThdSleepMilliseconds(1);
  // }

  i2cReleaseBus(&I2CD2);
  WM8731_I2CStop();
  chThdSleepMilliseconds(1);

  if (status == RDY_OK)
    return true;
  else
    return false;

}

uint16_t codec_WM8731_hw_init(uint16_t samplerate) {

  // Code ported from 'control_wm8731.cpp' in Teensy Audio Library <3

  if (!WM8731_writeRegister(WM8731_REG_RESET, 0))
    return false; // no WM8731 chip responding

  chThdSleepMilliseconds(5);

    WM8731_writeRegister(WM8731_REG_INTERFACE, 0b00001110); // I2S, 32 bit, MCLK slave
  if (samplerate == 48000)
    // WM8731_writeRegister(WM8731_REG_SAMPLING,  0b00000000); // 12.288mhz, 256fs, 48khz in, 48khz out
    WM8731_writeRegister(WM8731_REG_SAMPLING,  0b01000000); // 12.288mhz, 256fs, 48khz in, 48khz out, clkdiv2
  else if (samplerate == 44100)
    WM8731_writeRegister(WM8731_REG_SAMPLING,  0b00100000); // 12.288mhz, 256fs, 44.1khz in, 44.1khz out

  /* In order to prevent pops, the DAC should first be soft-muted (DACMU),
  * the output should then be de-selected from the line and headphone output
  * (DACSEL), then the DAC powered down (DACPD).
  */

  WM8731_writeRegister(WM8731_REG_DIGITAL, 0x08);   // DAC soft mute
  WM8731_writeRegister(WM8731_REG_ANALOG, 0x00);    // disable all

  WM8731_writeRegister(WM8731_REG_POWERDOWN, 0x00); // diable all powerdown

  WM8731_writeRegister(WM8731_REG_LHEADOUT, 0x80);  // volume off
  WM8731_writeRegister(WM8731_REG_RHEADOUT, 0x80);

  chThdSleepMilliseconds(100); // how long to power up?

	WM8731_writeRegister(WM8731_REG_ACTIVE, 1);

	chThdSleepMilliseconds(5);

	WM8731_writeRegister(WM8731_REG_DIGITAL, 0x00);   // DAC unmuted
	WM8731_writeRegister(WM8731_REG_ANALOG, 0x10);    // DAC selected

	return true;
}

static void dma_i2s_interrupt(void* dat, uint32_t flags) {
  (void)dat;
  (void)flags;
  codec_interrupt_timestamp = hal_lld_get_counter_value();
  if ((i2sdma_WM8731)->stream->CR & STM32_DMA_CR_CT) {
    computebufI(rbuf, buf);
  }
  else {
    computebufI(rbuf2, buf2);
  }
  dmaStreamClearInterrupt(i2sdma_WM8731);
}

static void dma_i2s_rxinterrupt(void* dat, uint32_t flags) {
  (void)dat;
  (void)flags;
  dmaStreamClearInterrupt(i2sdma_WM8731rx);
}

static void codec_WM8731_dma_init(void) {
  // TX
  i2sdma_WM8731 = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);

  uint32_t i2stxdmamode = STM32_DMA_CR_CHSEL(I2S2_TX_DMA_CHANNEL)
      | STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) | STM32_DMA_CR_DIR_M2P
      | STM32_DMA_CR_TEIE | STM32_DMA_CR_TCIE | STM32_DMA_CR_DBM | // double buffer mode
      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_WORD;

  bool_t b = dmaStreamAllocate(i2sdma_WM8731, STM32_SPI_SPI2_IRQ_PRIORITY,
                               (stm32_dmaisr_t)dma_i2s_interrupt,
                               (void *)&SPID2);

//  if (!b)
//  chprintf((BaseChannel*)&SD2, "DMA Allocated Successfully to I2S2\r\n");

  dmaStreamSetPeripheral(i2sdma_WM8731, &(CODEC_WM8731_I2S->DR));
// my double buffer test
  dmaStreamSetMemory0(i2sdma_WM8731, buf);
  dmaStreamSetMemory1(i2sdma_WM8731, buf2);
  dmaStreamSetTransactionSize(i2sdma_WM8731, 64);
  dmaStreamSetMode(i2sdma_WM8731, i2stxdmamode | STM32_DMA_CR_MINC);
//  dmaStreamSetFIFO(i2sdma,

  // RX
#if 1
  i2sdma_WM8731rx = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);

  uint32_t i2srxdmamode = STM32_DMA_CR_CHSEL(3/*I2S2_RX_DMA_CHANNEL*/)
      | STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) | STM32_DMA_CR_DIR_P2M |
//  STM32_DMA_CR_DMEIE |
      STM32_DMA_CR_TEIE | STM32_DMA_CR_TCIE | STM32_DMA_CR_DBM | // double buffer mode
      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_WORD;

  b = dmaStreamAllocate(i2sdma_WM8731rx, STM32_SPI_SPI2_IRQ_PRIORITY,
                        (stm32_dmaisr_t)dma_i2s_rxinterrupt, (void *)&SPID2);

  while (b) {
    // failed
  }
//  if (!b)
//  chprintf((BaseChannel*)&SD2, "DMA Allocated Successfully to I2S2\r\n");

//  dmaStreamSetPeripheral(i2sdma_ADAU1961rx, &(CODEC_ADAU1961_I2Sext->DR));
  dmaStreamSetPeripheral(i2sdma_WM8731rx, &(CODEC_WM8731_I2Sext->DR));
// my double buffer test
  dmaStreamSetMemory0(i2sdma_WM8731rx, rbuf2);
  dmaStreamSetMemory1(i2sdma_WM8731rx, rbuf);
  dmaStreamSetTransactionSize(i2sdma_WM8731rx, 64); //PLAYBACK_BUFFER_SIZE);
  dmaStreamSetMode(i2sdma_WM8731rx, i2srxdmamode | STM32_DMA_CR_MINC);

  dmaStreamClearInterrupt(i2sdma_WM8731rx);
  dmaStreamEnable(i2sdma_WM8731rx);
#endif
  // enable
  dmaStreamClearInterrupt(i2sdma_WM8731);
  dmaStreamEnable(i2sdma_WM8731);
}

void codec_WM8731_i2s_init(uint16_t sampleRate) {

#if 0
  /* CODEC_I2S output pins configuration: WS, SCK SD0 and SDI pins ------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SDO_PIN | CODEC_I2S_SDI_PIN | CODEC_I2S_WS_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);

  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN;
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);

  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_WS_PINSRC, CODEC_I2S_GPIO_AF);
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, CODEC_I2S_GPIO_AF);
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SDO_PINSRC, CODEC_I2S_GPIO_AF);
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SDI_PINSRC, CODEC_I2S_GPIO_AF);
  GPIO_PinAFConfig(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PINSRC, CODEC_I2S_GPIO_AF);
#endif
  /*
   palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL|PAL_MODE_ALTERNATE(5));
   palSetPadMode(GPIOB, 13, PAL_MODE_OUTPUT_PUSHPULL|PAL_MODE_ALTERNATE(5));
   palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5));
   palSetPadMode(GPIOB, 15, PAL_MODE_OUTPUT_PUSHPULL|PAL_MODE_ALTERNATE(5));
   palSetPadMode(GPIOC, 6, PAL_MODE_OUTPUT_PUSHPULL|PAL_MODE_ALTERNATE(5));
   */

#if 1
  palSetPadMode(GPIOB, 12, PAL_MODE_ALTERNATE(5));
  // i2s2ws
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5));
  // i2s2ck
  palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5));
  // i2s2_ext_sd
  palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5));
  // i2s2_sd
#else // test if codec is connected
  palSetPadMode(GPIOB, 12, PAL_MODE_INPUT); // i2s2ws
  palSetPadMode(GPIOB, 13, PAL_MODE_INPUT);// i2s2ck
  palSetPadMode(GPIOB, 14, PAL_MODE_INPUT);// i2s2_ext_sd
  palSetPadMode(GPIOB, 15, PAL_MODE_INPUT);// i2s2_sd
#endif

  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(5));
  // i2s2_mck

// SPI2 in I2S Mode, Master
  CODEC_WM8731_I2S_ENABLE;

#if STM_IS_I2S_MASTER
  CODEC_WM8731_I2S ->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG_1 | SPI_I2SCFGR_DATLEN_1; /* MASTER TRANSMIT */

  uint16_t prescale;
  uint32_t pllfreq = STM32_PLLI2SVCO / STM32_PLLI2SR_VALUE;
  // Master clock mode Fs * 256
  prescale = (pllfreq * 10) / (256 * sampleRate) + 5;
  prescale /= 10;

  if (prescale > 0xFF || prescale < 2)
  prescale = 2;

  if (prescale & 0x01)
  CODEC_WM8731_I2S ->I2SPR = SPI_I2SPR_MCKOE | SPI_I2SPR_ODD | (prescale >> 1);
  else
  CODEC_WM8731_I2S ->I2SPR = SPI_I2SPR_MCKOE | (prescale >> 1);

  CODEC_WM8731_I2Sext ->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG_0 | SPI_I2SCFGR_DATLEN_1; /* SLAVE RECEIVE*/
  CODEC_WM8731_I2Sext ->I2SPR = 0x0002;

#else
  CODEC_WM8731_I2S->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_DATLEN_1; /* SLAVE TRANSMIT, 32bit */

  // generate 8MHz clock on MCK pin with PWM...
  static const PWMConfig pwmcfg = {168000000, /* 400kHz PWM clock frequency.  */
                                   21, /* PWM period is 128 cycles.    */
                                   NULL, { {PWM_OUTPUT_ACTIVE_HIGH, NULL}, {
                                       PWM_OUTPUT_ACTIVE_HIGH, NULL},
                                          {PWM_OUTPUT_ACTIVE_HIGH, NULL}, {
                                              PWM_OUTPUT_ACTIVE_HIGH, NULL}},
                                   /* HW dependent part.*/
                                   0,
                                   0};
  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(3));
  // i2s2_mck
  pwmStart(&PWMD8, &pwmcfg);
  pwmEnableChannel(&PWMD8, 0, 10);

  CODEC_WM8731_I2Sext->I2SCFGR = SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG_0
      | SPI_I2SCFGR_DATLEN_1; /* SLAVE RECEIVE, 32bit*/
  CODEC_WM8731_I2Sext->I2SPR = 0x0002;

#endif
//  CODEC_WM8731_I2S ->I2SPR = SPI_I2SPR_MCKOE |

//// FULL DUPLEX CONFIG

  ;

  codec_WM8731_dma_init();

// Enable I2S DMA Request
  CODEC_WM8731_I2S->CR2 = SPI_CR2_TXDMAEN;  //|SPI_CR2_RXDMAEN;
//  CODEC_WM8731_I2S ->CR2 = SPI_CR2_RXNEIE;
//  CODEC_WM8731_I2S ->CR2 = SPI_CR2_TXEIE;

  CODEC_WM8731_I2Sext->CR2 = SPI_CR2_RXDMAEN;
//  CODEC_WM8731_I2S ->CR2 = SPI_CR2_TXDMAEN;

// Now Enable I2S
  CODEC_WM8731_I2S->I2SCFGR |= SPI_I2SCFGR_I2SE;
  CODEC_WM8731_I2Sext->I2SCFGR |= SPI_I2SCFGR_I2SE;
}

void codec_WM8731_Stop(void) {
  CODEC_WM8731_I2S->I2SCFGR = 0;
  CODEC_WM8731_I2Sext->I2SCFGR = 0;
  CODEC_WM8731_I2S->CR2 = 0;
  CODEC_WM8731_I2Sext->CR2 = 0;

}
